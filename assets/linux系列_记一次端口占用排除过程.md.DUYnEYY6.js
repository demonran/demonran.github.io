import{_ as a,c as s,o as n,a1 as p}from"./chunks/framework.rLRl8Q3O.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"linux系列/记一次端口占用排除过程.md","filePath":"linux系列/记一次端口占用排除过程.md","lastUpdated":1717060235000}'),e={name:"linux系列/记一次端口占用排除过程.md"},l=p(`<h2 id="记一次端口占用排除过程" tabindex="-1">记一次端口占用排除过程 <a class="header-anchor" href="#记一次端口占用排除过程" aria-label="Permalink to &quot;记一次端口占用排除过程&quot;">​</a></h2><h4 id="问题现象" tabindex="-1">问题现象 <a class="header-anchor" href="#问题现象" aria-label="Permalink to &quot;问题现象&quot;">​</a></h4><p>公司项目项目采用虚拟机部署， 突然有一天某个微服务重启提示&quot;端口占用&quot;。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Caused by: java.net.BindException: 地址已在使用</span></span>
<span class="line"><span>        at sun.nio.ch.Net.bind0(Native Method)</span></span>
<span class="line"><span>        at sun.nio.ch.Net.bind(Net.java:433)</span></span>
<span class="line"><span>        at sun.nio.ch.Net.bind(Net.java:425)</span></span>
<span class="line"><span>        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)</span></span>
<span class="line"><span>        at org.apache.tomcat.util.net.NioEndpoint.initServerSocket(NioEndpoint.java:275)</span></span>
<span class="line"><span>        at org.apache.tomcat.util.net.NioEndpoint.bind(NioEndpoint.java:230)</span></span>
<span class="line"><span>        at org.apache.tomcat.util.net.AbstractEndpoint.bindWithCleanup(AbstractEndpoint.java:1227)</span></span>
<span class="line"><span>        at org.apache.tomcat.util.net.AbstractEndpoint.start(AbstractEndpoint.java:1313)</span></span>
<span class="line"><span>        at org.apache.coyote.AbstractProtocol.start(AbstractProtocol.java:614)</span></span>
<span class="line"><span>        at org.apache.catalina.connector.Connector.startInternal(Connector.java:1074)</span></span>
<span class="line"><span>        ... 28 common frames omitted</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="问题场景说明" tabindex="-1">问题场景说明 <a class="header-anchor" href="#问题场景说明" aria-label="Permalink to &quot;问题场景说明&quot;">​</a></h4><p>公司的微服务监听端口都是规划好的从30000-31000, 端口肯定不会重复，当前服务器上也没有安装其他系统软件。</p><p>通过命令查询端口占用情况，TCP和UDP端口又不会在用， 所以查询tcp的监听端口， 也没有找到30010端口占用情况。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>netstat -ntpl </span></span>
<span class="line"><span>Active Internet connections (only servers)</span></span>
<span class="line"><span>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span></span>
<span class="line"><span>tcp        0      0 0.0.0.0:8848            0.0.0.0:*               LISTEN      3549133/nginx: mast</span></span>
<span class="line"><span>tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3549133/nginx: mast</span></span>
<span class="line"><span>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      901/sshd: /usr/sbin</span></span>
<span class="line"><span>tcp        0      0 0.0.0.0:9848            0.0.0.0:*               LISTEN      3549133/nginx: mast</span></span>
<span class="line"><span>tcp6       0      0 :::40004                :::*                    LISTEN      1976342/java</span></span>
<span class="line"><span>tcp6       0      0 :::40005                :::*                    LISTEN      1980683/java</span></span>
<span class="line"><span>tcp6       0      0 :::40006                :::*                    LISTEN      2709439/java</span></span>
<span class="line"><span>tcp6       0      0 :::40007                :::*                    LISTEN      1982779/java</span></span>
<span class="line"><span>tcp6       0      0 :::40008                :::*                    LISTEN      2090475/java</span></span>
<span class="line"><span>tcp6       0      0 :::30001                :::*                    LISTEN      2007172/java</span></span>
<span class="line"><span>tcp6       0      0 :::30002                :::*                    LISTEN      2704486/java</span></span>
<span class="line"><span>tcp6       0      0 :::30003                :::*                    LISTEN      2005364/java</span></span>
<span class="line"><span>tcp6       0      0 :::30004                :::*                    LISTEN      2623420/java</span></span>
<span class="line"><span>tcp6       0      0 :::30005                :::*                    LISTEN      2076669/java</span></span>
<span class="line"><span>tcp6       0      0 :::30006                :::*                    LISTEN      2052751/java</span></span>
<span class="line"><span>tcp6       0      0 :::22                   :::*                    LISTEN      901/sshd: /usr/sbin</span></span>
<span class="line"><span>tcp6       0      0 :::30007                :::*                    LISTEN      2049860/java</span></span>
<span class="line"><span>tcp6       0      0 :::30008                :::*                    LISTEN      2000677/java</span></span>
<span class="line"><span>tcp6       0      0 :::30009                :::*                    LISTEN      1998847/java</span></span>
<span class="line"><span>tcp6       0      0 :::30010                :::*                    LISTEN      2725547/java</span></span>
<span class="line"><span>tcp6       0      0 :::40001                :::*                    LISTEN      1986863/java</span></span>
<span class="line"><span>tcp6       0      0 :::40002                :::*                    LISTEN      2728715/java</span></span>
<span class="line"><span>tcp6       0      0 :::60003                :::*                    LISTEN      1984948/java</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>既然没有监听端口，是不是某个进程临时使用了当前端口呢，于是使用lsof命令再次查看端口占用, 果然有一个ESTABLISHED状态tcp链接，</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>lsof -i:30010</span></span>
<span class="line"><span>COMMAND     PID USER   FD   TYPE    DEVICE SIZE/OFF NODE NAME</span></span>
<span class="line"><span>java    1988719 root  272u  IPv6 248498713      0t0  TCP Test-XIY-ZTServer-10:30010-&gt;localhost.localdomain:afs3-fileserver (ESTABLISHED)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过信息可排查出来是有一个进程ID为1988719的java进程占用了该端口号，但是现在还无法确定具体是什么链接， 此时可以使用netstat -anp | grep 30010查看</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>netstat -anp | grep 30010</span></span>
<span class="line"><span>tcp6       0      0 10.11.xx.xx:30010       10.11.xx.xx:7000        ESTABLISHED 1986863/java</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>确定是连接到了另一台机器的7000端口， 登录另一台服务器查看7000端口的进程服务为redis.</p><p>此时的方案是先关闭1988719的java进程，然后启动服务。 此时服务启动正常。</p><h4 id="分析" tabindex="-1">分析 <a class="header-anchor" href="#分析" aria-label="Permalink to &quot;分析&quot;">​</a></h4><p>在linux网络协议中， TCP连接需要4元素(源IP, 源PORT, 目标IP, 目标PORT), 因源PORT不确定， linux网络系统会随机选择一个本地未占用的端口。</p><p>在建立redis连接过程中，刚好有一个微服务再重启，释放的端口刚好被redis连接的客户端占用。因为redis客户端本地使用的连接池，连接会一直保持不会断开，导致微服务器启动时端口一直被占用。</p><h4 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h4><p>对于本次问题，虽然临时解决了改问题， 并且该问题出现的机率不算大，因为微服务中的长链接基本上都会使用池化技术， 但是问题还是有出息的概率性。所以需要有一种永久解决的办法。</p><p>首先，我们需要了解linux随机端口的范围， 通过sysctl查看</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>net.ipv4.ip_local_port_range = 1024	65000</span></span>
<span class="line"><span>net.ipv4.ping_group_range = 1	0</span></span>
<span class="line"><span>net.ipv6.flowlabel_state_ranges = 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过结果可知， 随机端口范围在1024-65000之间， 我们微服务的端口范围在30000-30100之间，所以肯定会存在端口占用可能性。</p><p>然后， 重写分配端口 系统服务端口改为10000 - 10100， 随机端口改为20000 - 65000之间， 错开端口使用范围。</p><p>修改随机端口配置</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vi</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/sysctl.conf</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">net.ipv4.ip_local_port_range</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">=20000</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 65000</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#配置立即生效：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sysctl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><ol><li>微服务出现TCP端口占用，不一定只有固定分配端口， 还有自动分配端口占用</li><li>微服务的端口需要和自动分配端口隔离开</li><li>尽量不要在一个系统中部署太多服务。</li></ol>`,27),i=[l];function t(r,c,o,b,d,u){return n(),s("div",null,i)}const v=a(e,[["render",t]]);export{m as __pageData,v as default};
